//-------------------------------------------------------------------------------//
//Array, en este caso de numeros del 0 al 9 convertido a string
function digits() {
  let array = []; // crea un array vacio
  for (let i = 0; i < 10; i++) {
    array.push(i); // cada numero (i) es pusheado al array vacio por cada iteracion
  }
  let arrayFinal = array.toString(); // convierte el array a string y lo guarda en una variable
  return arrayFinal;
}

//-------------------------------------------------------------------------------//
//Contador de vocales
function countVowels(cadena) {
  let totalVocales = 0; // contador de vocales guardado en variable

  //el for recorre el string y si alguna letra coincide con las vocales
  //le suma 1 a la variable que cuenta las vocales
  for (let i = 0; i < cadena.length; i++) {
    if (
      cadena[i] === "a" ||
      cadena[i] === "A" ||
      cadena[i] === "e" ||
      cadena[i] === "E" ||
      cadena[i] === "i" ||
      cadena[i] === "I" ||
      cadena[i] === "o" ||
      cadena[i] === "O" ||
      cadena[i] === "u" ||
      cadena[i] === "U"
    ) {
      totalVocales++;
    }
  }

  return totalVocales;
}

//-------------------------------------------------------------------------------//
//Removedor de vocales
function removeVowels(str) {
  var vowels = "aeiouAEIOU";
  let output = "";

  for (let i = 0; i < str.length; i++) {
    if (!vowels.includes(str[i])) {
      output += str[i];
    }
  }
  return output;
}

//-------------------------------------------------------------------------------//
//Conversor de unidades de distancia

function convert(distancia, unidad) {
  let resultado;
  if (unidad == "km" || unidad == "KM" || unidad == "Km" || unidad == "kM") {
    resultado = Math.round(distancia * 0.621371) + " mi";
  } else if (
    unidad == "mi" ||
    unidad == "MI" ||
    unidad == "Mi" ||
    unidad == "mI"
  ) {
    resultado = Math.round(distancia * 1.60934) + " km";
  }

  return resultado;
}

//Esta funci√≥n toma como par√°metros un n√∫mero (distancia) y un string (unidad).
//Dependiendo de la unidad ingresada, la funci√≥n convierte la distancia ingresada a la unidad opuesta.
//Si la unidad ingresada es "km", la distancia se convertir√° a millas.Si la unidad ingresada es
//"mi", la distancia se convertir√° a kil√≥metros.El resultado de la conversi√≥n se redondear√° con
//Math.round()

//-------------------------------------------------------------------------------//
//Suma los numeros multiplos de 3, 5 y de 15 contenidos en el numero pasado por parametro

function sumMultiples(num) {
  let sum = 0;
  for (let i = 0; i < num; i++) {
    if (i % 15 == 0) {
      // si es multiplo de 3 y 5
      sum += i; // se agrega el n√∫mero a la suma
    } else if (i % 3 === 0 || i % 5 === 0) {
      // si es multiplo de 3 o 5
      sum += i; // se agrega el n√∫mero a la suma
    }
  }
  return sum;
}

/* La funci√≥n comienza declarando una variable sum que se inicializar√° en 0.
Despu√©s, se usa un bucle for para recorrer los n√∫meros desde 0 hasta el n√∫mero pasado
 como par√°metro.Dentro del bucle for, se comprueba si el n√∫mero es m√∫ltiplo de 3 o de 5 
 con los operadores de m√≥dulo %.Si se cumple la condici√≥n, se agrega el n√∫mero a la suma y
  se sigue con el siguiente n√∫mero.
 */

//-------------------------------------------------------------------------------//
//retorna el n√∫mero del array que aparezca un n√∫mero impar de veces.
// Siempre se recibir√° un array con un s√≥lo n√∫mero con esas caracter√≠sticas.
function findOddNumber(numbers) {
  let counter = 0;

  for (let i = 0; i < numbers.length; i++) {
    for (let j = 0; j < numbers.length; j++) {
      if (numbers[i] === numbers[j]) {
        counter++;
      }
    }
    if (counter % 2 !== 0) {
      return numbers[i];
    } else {
      counter = 0;
    }
  }
}

//-------------------------------------------------------------------------------//

/*Funci√≥n llamada optimalPath que recibe como
par√°metro un array de strings, que pueden ser: "NORTE", "SUR", "ESTE" y
"OESTE". Este array indica el camino que debe seguir un viajero para llegar a
determinado destino. El problema es que el camino propuesto por el array no es
√≥ptimo.

Por ejemplo, si el array de entrada es ["NORTE", "SUR"] el camino no es √≥ptimo, ya
que antes que avanzar y retroceder al mismo lugar, es preferible quedarse quieto.
Por lo tanto, la funci√≥n en este caso deber√≠a retornar un array vac√≠o [].
üëâConsiderar que "NORTE" y "SUR" son opuestos, al igual que "ESTE" y "OESTE",
y se cancelan si est√°n uno inmediatamente despu√©s del otro. Es decir, en el camino
final, estos puntos cardinales no pueden aparecer juntos.


Ejemplos:
InputOutput
optimalPath(["NORTE", "SUR"])[]
optimalPath(["NORTE", "SUR", "SUR"])["SUR"]
optimalPath(["NORTE", "SUR", "SUR", "NORTE"])[]
optimalPath(["NORTE", "SUR", "SUR", "SUR"])["SUR", "SUR"]
optimalPath(["NORTE", "SUR", "SUR", "ESTE", "OESTE", "NORTE", "OESTE"])["OESTE"]
optimalPath(["NORTE", "OESTE", "SUR", "ESTE"])["NORTE", "OESTE",
"SUR", "ESTE"]*/
//Camino optimo, recibe como parametro puntos cardinales y devuelve el mejor camino a recorrer
function optimalPath(roads) {
  let bestPath = [];
  let bestPath1 = [];

  for (let i = 0; i < roads.length; i++) {
    if (
      (roads[i] === "NORTE" && roads[i + 1] === "SUR") ||
      (roads[i] === "SUR" && roads[i + 1] === "NORTE") ||
      (roads[i] === "ESTE" && roads[i + 1] === "OESTE") ||
      (roads[i] === "OESTE" && roads[i + 1] === "ESTE")
    ) {
      i = i + 1;
    } else {
      bestPath.push(roads[i]);
    }
  }

  for (let i = 0; i < bestPath.length; i++) {
    if (
      (bestPath[i] === "NORTE" && bestPath[i + 1] === "SUR") ||
      (bestPath[i] === "SUR" && bestPath[i + 1] === "NORTE") ||
      (bestPath[i] === "ESTE" && bestPath[i + 1] === "OESTE") ||
      (bestPath[i] === "OESTE" && bestPath[i + 1] === "ESTE")
    ) {
      i = i + 1;
    } else {
      bestPath1.push(bestPath[i]);
    }
  }

  return bestPath1;
}

//-------------------------------------------------------------------------------//

/*Funci√≥n en JavaScript llamada correctParentheses que reciba como par√°metro un string compuesto por par√©ntesis curvos
"(" y/o ")", y retorna true en caso de que los par√©ntesis est√©n ordenados de la
forma correcta (que se abran y cierren de forma consistente). En caso de no estarlo,
la funci√≥n retorna false.
  
Ejemplos:
Input                   Output
correctParentheses("()")true
correctParentheses(")(")false
correctParentheses(")(()))")false
correctParentheses("(")false
correctParentheses("()(")false
correctParentheses("(())((()())())")true */

function correctParentheses(parentheses) {
  let count = 0;

  if (parentheses.length % 2 !== 0) return false;
  if (parentheses[0] === ")") return false;

  for (const character of parentheses) {
    if (character === "(") count++;
    if (character === ")") count--;
    if (count < 0) return false;
  }

  return count === 0;
}

//-------------------------------------------------------------------------------//

/* Funci√≥n en JavaScript llamada encrypt13 que recibe
como par√°metro un string y retorna como resultado un nuevo string pero
‚Äúencriptado‚Äù.
El nuevo string tiene las letras ‚Äúcorridas‚Äù 13 lugares. Por ejemplo, a la letra
‚ÄúA‚Äù le corresponder√° la ‚ÄúN‚Äù, as√≠ como a la ‚Äúa‚Äù le corresponder√° la ‚Äún‚Äù. A la letra ‚ÄúT‚Äù le
corresponder√° la ‚ÄúG‚Äù y a la letra ‚Äút‚Äù la ‚Äúg‚Äù. Es decir, las min√∫sculas se transforman en
otra letra min√∫scula y las may√∫sculas tambi√©n se transforman en may√∫scula.
S√≥lo se deber√°n transformar (‚Äúcorrer‚Äù) letras del alfabeto ingl√©s. Cualquier otro
car√°cter deber√° quedar incambiado.

Ejemplos:
Input              Output
encrypt13("hola")"ubyn"
encrypt13("CHAU")"PUNH"
encrypt13("T√≠tulo")"G√≠ghyb"
encrypt13("HACK academy 2022")"UNPX npnqrzl 2022"
 */

//Encripta un string corriendo cada caract√©r 13 lugares en el alfabeto
function encrypt13(word) {
  const alphabet = "abcdefghijklmnopqrstuvwxyz";

  // Convierte la cadena `word` en un array de caracteres y luego aplica la funci√≥n `map` a cada uno de ellos
  const encryptedChars = [...word].map((char) => {
    // Busca la posici√≥n del caracter en el alfabeto
    const index = alphabet.indexOf(char.toLowerCase());
    // Si el caracter no est√° en el alfabeto, lo devuelve sin cifrar
    if (index === -1) {
      return char;
    }
    // Aplica la transformaci√≥n de 13 posiciones en el alfabeto al caracter
    const newIndex = (index + 13) % 26;
    const newChar = alphabet[newIndex];
    // Si el caracter original era una may√∫scula, convierte el caracter cifrado a may√∫scula
    return char === char.toUpperCase() ? newChar.toUpperCase() : newChar;
  });

  // Convierte el array de caracteres cifrados en una cadena
  return encryptedChars.join("");
}

//-------------------------------------------------------------------------------//

/*Versi√≥n de ‚ÄúPiedra, Papel o Tijera‚Äù, para jugar
contra la computadora.
Se crea una funci√≥n en JavaScript llamada play que recibe
como par√°metro un string que puede ser ‚ÄúPiedra‚Äù, ‚ÄúPapel‚Äù o ‚ÄúTijera‚Äù.
La funci√≥n deber√° definir qu√© movimiento hizo la computadora y en base a eso
determinar un ganador.
  Ejemplos:

Input                                     Output
play("Piedra")"La computadora eligi√≥ Papel. Perdiste."
play("Piedra")"La computadora eligi√≥ Tijeras. Ganaste."
play("Papel")"La computadora eligi√≥ Papel. Empataron."
play("Papel")"La computadora eligi√≥ Tijeras. Perdiste."
 */
//El juego piedra papel o tijera vs la maquina
function play(str) {
  let player1 = str;
  let possibilities = ["piedra", "papel", "tijeras"];
  let option = Math.floor(Math.random() * possibilities.length);
  let computer = possibilities[option];
  let result = "";

  // -------------casos en que el usuario gana--------------
  if (
    (player1 === "piedra" && computer === "tijeras") ||
    (player1 === "papel" && computer === "piedra") ||
    (player1 === "tijeras" && computer === "papel")
  ) {
    result = `la computadora eligi√≥ ${computer}. Ganaste`;
  }

  // ------------casos en que hay empate----------------
  else if (
    (player1 === "piedra" && computer === "piedra") ||
    (player1 === "papel" && computer === "papel") ||
    (player1 === "tijeras" && computer === "tijeras")
  ) {
    result = `la computadora eligi√≥ ${computer}. Empataste`;
  }

  // ------------casos en que el usuario pierde----------------
  else if (
    (player1 === "piedra" && computer === "papel") ||
    (player1 === "papel" && computer === "tijeras") ||
    (player1 === "tijeras" && computer === "piedra")
  ) {
    result = `la computadora eligi√≥ ${computer}. Perdiste`;
  }
  return result;
}

//-------------------------------------------------------------------------------//
/* 
Funci√≥n llamada durationForHumans que
recibe como par√°metro un n√∫mero entero (representando una cantidad de
segundos) y retorna un string con un texto que indique la cantidad de tiempo que
transcurri√≥, pero con un formato f√°cil de leer por humanos.

Ejemplos:
Input------------------Output
durationForHumans(0)"ahora"
durationForHumans(62)"1 minuto y 2 segundos"
durationForHumans(3662)"1 hora, 1 minuto y 2 segundos"
durationForHumans(43424234)"1 a√±o, 137 d√≠as, 14 horas, 17 minutos y 14 segundos"
durationForHumans(4342440)"50 d√≠as, 6 horas y 14 minutos"
 */

function durationForHumans(seconds) {
  if (seconds === 0) {
    return "ahora";
  }

  const minute = 60;
  const hour = minute * 60;
  const day = hour * 24;
  const year = day * 365;

  const years = Math.floor(seconds / year);
  seconds %= year;
  const days = Math.floor(seconds / day);
  seconds %= day;
  const hours = Math.floor(seconds / hour);
  seconds %= hour;
  const minutes = Math.floor(seconds / minute);
  seconds %= minute;

  const components = [];

  if (years > 0) {
    const suffix = years === 1 ? "" : "s";
    components.push(`${years} a√±o${suffix}`);
  }

  if (days > 0) {
    const suffix = days === 1 ? "" : "s";
    components.push(`${days} d√≠a${suffix}`);
  }

  if (hours > 0) {
    const suffix = hours === 1 ? "" : "s";
    components.push(`${hours} hora${suffix}`);
  }

  if (minutes > 0) {
    const suffix = minutes === 1 ? "" : "s";
    components.push(`${minutes} minuto${suffix}`);
  }

  if (seconds > 0) {
    const suffix = seconds === 1 ? "" : "s";
    components.push(`${seconds} segundo${suffix}`);
  }

  const lastIndex = components.length - 1;
  return components.reduce((text, component, index) => {
    if (index === 0) {
      return component;
    } else if (index === lastIndex) {
      return `${text} y ${component}`;
    } else {
      return `${text}, ${component}`;
    }
  }, "");
}